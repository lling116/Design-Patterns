1.概念、    单例模式是一种对象创建型模式，使用单例模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中， 该类只存在一个实例对象。GoF对单例模式的定义是：保证一个类、只有一个实例存在，同时提供能对该实例加以访问的全局访问方法。2.为什么使用单列模式在应用系统开发中，我们常常有以下需求：- 在多个线程之间，比如初始化一次socket资源- 在整个程序空间使用全局变量，共享资源- 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等。因为Singleton模式可以保证为一个类只生成唯一的实例对象，所以这些情况，Singleton模式就派上用场了。2.实现步骤：  a)构造函数私有化  b)提供一个全局的静态方法（全局访问点）  c)在类中定义一个静态指针，指向本类的变量的静态变量指针3.单列实现的两种模式：    3.1懒汉式：当我们用到该类的时候在创建，存在线程安全问题    3.2饿汉式：在用之前就创建	4.多线程梳理：为了在多线程程序中解决同步问题，Windows提供了四种主要的同步对象，每种对象相对于线程有两种状态――信号状态（signal state）和非信号状态（nonsignalstate）。当相关联的同步对象处于信号状态时，线程可以执行（访问共享资源），反之必须等待。这四种同步对象是：（1）事件对象（Event）。事件对象作为标志在线程间传递信号。一个或多个线程可等待一个事件对象，当指定的事件发生时，事件对象通知等待线程可以开始执行。它有两种类型：自动重置（auto-reset）事件和手动重置（manual-reset）事件。（2）临界区（Critical Section）。临界区对象通过提供一个进程内所有线程必须共享的对象来控制线程。只有拥有那个对象的线程可以访问保护资源。在另一个线程可以访问该资源之前，前一个线程必须释放临界区对象，以便新的线程可以索取对象的访问权。（3）互斥量（Mutex Semaphore）。互斥量的工作方式非常类似于临界区，只是互斥量不仅保护一个进程内为多个线程使用的共享资源，而且还可以保护系统中两个或多个进程之间的的共享资源。（4）信号量（Semaphore）。信号量可以允许一个或有限个线程访问共享资源。它是通过计数器来实现的，初始化时赋予计数器以可用资源数，当将信号量提供给一个线程时，计数器的值减1，当一个线程释放它时，计数器值加1。当计数器值小于等于0时，相应线程必须等待。信号量是Windows98同步系统的核心。从本质上讲，互斥量是信号量的一种特殊形式。Linux系统中的线程间通信方式主要以下几种:*  锁机制：包括互斥锁、条件变量、读写锁和自旋锁。   互斥锁确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的 线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个 等待线程能获得该锁取决于内核的调度。  *读写锁当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，    当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。     自旋锁上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。*  信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量*  信号机制(Signal)：类似进程间的信号处理5.懒汉式遇到多线程：*if(m_Singleton == NULL)两次？   *第一次是判断之前是否已经创建；如果已经创建多线程没必要进入临界区   *第二次判断是因为开始还没创建，避免线程重复创建！